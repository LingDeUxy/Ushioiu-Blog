{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"HashMap底层原理","date":"2022-10-03T02:42:33.000Z","updated":"2023-07-06T07:04:43.629Z","comments":true,"path":"api/articles/HashMap底层原理.json","keywords":null,"cover":"/img/post/like.jpg","content":"<h1 id=\"HashMap的原理与实现\"><a href=\"#HashMap的原理与实现\" class=\"headerlink\" title=\"HashMap的原理与实现\"></a>HashMap的原理与实现</h1><p><strong>JDK1.8之前：数组+链表</strong></p>\n<p><strong>JDK1.8：数组+链表&#x2F;红黑树</strong></p>\n<h3 id=\"对比：\"><a href=\"#对比：\" class=\"headerlink\" title=\"对比：\"></a>对比：</h3><ol>\n<li>jdk8当链表大于等于8会变成红黑树</li>\n<li>jdk7采用的是插入头节点，jdk8采用的是插入尾节点（因为红黑树）</li>\n<li>jdk8，hash算法的简化，并且不会出现死循环</li>\n</ol>\n<h2 id=\"1-扩容机制\"><a href=\"#1-扩容机制\" class=\"headerlink\" title=\"1.扩容机制\"></a>1.扩容机制</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n   * The load factor used when none specified in constructor.\n   *&#x2F;\n  static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n  &#x2F;**\n   *默认的负载因子是0.75f,也就是75% 负载因子的作用就是计算扩容阈值用，比如说使用\n   *无参构造方法创建的HashMap 对象，他初始长度默认是16  阈值 &#x3D; 当前长度 * 0.75  就\n   *能算出阈值，当当前长度大于等于阈值的时候HashMap就会进行自动扩容\n   *--扩容因子越大 越容易hash冲突，越小消耗空间越大 ，0.75比较合适\n   *--保证扩容后容量是2的幂，0.75也比较合适（位运算）\n   *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2-储存原理\"><a href=\"#2-储存原理\" class=\"headerlink\" title=\"2.储存原理\"></a>2.储存原理</h2><ol>\n<li>把key通过hash算法获取hash值</li>\n<li>调用indexFor方法，通过获取到的hash值以及数组的长度算出数组的下标</li>\n<li>把key，value存到数组对应下标中（封装成node对象，如果有值了，就会尾插成链表）</li>\n<li>特殊情况也就是链表变成红黑树了：<ul>\n<li>没有对应的key然后插入，红黑树自己平衡</li>\n<li>有对应的key，实现替换，红黑树自动平衡</li>\n<li>简单提一句链表怎么转变红黑树：当链表长度大于等于8时，下一次的插入元素使链表依然大于等于8，那么就会重写，重现分配数据变成红黑树，当删除红黑树元素时，如果红黑树节点数（总结点）小于等于6，自动转成链表（再重写）。（至于hashmap扩容怎么数据迁移就很复杂了）</li>\n</ul>\n</li>\n</ol>\n","text":"HashMap的原理与实现JDK1.8之前：数组+链表 JDK1.8：数组+链表&#x2F;红黑树 对比： jdk8当链表大于等于8会变成红黑树 jdk7采用的是插入头节点，jdk8采用的是插入尾节点（因为红黑树） jdk8，hash算法的简化，并且不会出现死循环 1.扩容机制&...","link":"","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashMap%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">HashMap的原理与实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%EF%BC%9A\"><span class=\"toc-text\">对比：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.扩容机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%82%A8%E5%AD%98%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.储存原理</span></a></li></ol></li></ol>","author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}},"mapped":true,"prev_post":{"title":"系统架构演变","uid":"4d8037d4e1b16b3676d4b80209195ebc","slug":"系统架构发展","date":"2022-10-10T12:18:21.000Z","updated":"2023-07-06T07:03:23.739Z","comments":true,"path":"api/articles/系统架构发展.json","keywords":null,"cover":"/img/post/image-20230705191839467.png","text":"1.单体架构比如我们一开始写的ssm框架就是，从数据库访问层，业务逻辑层，控制层，从前端到后端都是一起开发的单体应用。 优点：部署在一个节点上，维护方便，开发方便。 缺点：一处错可能导致应用出错，代码耦合性高，不方便扩展，不利于开发大项目 2.垂直应用架构随着访问量的逐渐增大，单...","link":"","photos":[],"count_time":{"symbolsCount":650,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"系统架构","slug":"系统架构","count":1,"path":"api/tags/系统架构.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},"next_post":{}}