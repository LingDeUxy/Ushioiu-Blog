{"name":"java","slug":"java","count":7,"postlist":[{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"HashMap底层原理","date":"2022-10-03T02:42:33.000Z","updated":"2023-07-06T07:04:43.629Z","comments":true,"path":"api/articles/HashMap底层原理.json","keywords":null,"cover":"/img/post/like.jpg","text":"HashMap的原理与实现JDK1.8之前：数组+链表 JDK1.8：数组+链表&#x2F;红黑树 对比： jdk8当链表大于等于8会变成红黑树 jdk7采用的是插入头节点，jdk8采用的是插入尾节点（因为红黑树） jdk8，hash算法的简化，并且不会出现死循环 1.扩容机制&...","link":"","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"Spring事务传播机制","uid":"77f213291e2f36c95ae014c6c6641222","slug":"Spring事务传播机制","date":"2023-07-06T07:02:33.000Z","updated":"2023-07-06T07:02:36.391Z","comments":true,"path":"api/articles/Spring事务传播机制.json","keywords":null,"cover":"https://source.unsplash.com/9KcHl3Tp79k/1200x628","text":"Spring事务传播机制简单理解，加入A方法在执行中调用B方法，然后A方法事务是否对B方法事务，B方法是否有事务，是否能对A方法事务产生影响，这些都是传播机制决定的。 7种传播机制● REQUIRED：如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新的事务。这是默认的...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"事务传播机制","slug":"事务传播机制","count":1,"path":"api/tags/事务传播机制.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"系统架构演变","uid":"4d8037d4e1b16b3676d4b80209195ebc","slug":"系统架构发展","date":"2022-10-10T12:18:21.000Z","updated":"2023-07-06T07:03:23.739Z","comments":true,"path":"api/articles/系统架构发展.json","keywords":null,"cover":"/img/post/image-20230705191839467.png","text":"1.单体架构比如我们一开始写的ssm框架就是，从数据库访问层，业务逻辑层，控制层，从前端到后端都是一起开发的单体应用。 优点：部署在一个节点上，维护方便，开发方便。 缺点：一处错可能导致应用出错，代码耦合性高，不方便扩展，不利于开发大项目 2.垂直应用架构随着访问量的逐渐增大，单...","link":"","photos":[],"count_time":{"symbolsCount":650,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"系统架构","slug":"系统架构","count":1,"path":"api/tags/系统架构.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"设计模式-2创建型","uid":"624c128252ebb259922a7e5e7b2f25d4","slug":"设计模式-2创建型","date":"2022-12-23T03:42:12.000Z","updated":"2023-07-10T11:29:19.508Z","comments":true,"path":"api/articles/设计模式-2创建型.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"设计模式-2——创建型模式——工厂模式工厂模式（Factory Pattern）是Java中最常用的设计模式之一。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"设计模式-3结构型","uid":"76ea06e5385949b20227d2bc700d9a86","slug":"设计模式-3结构型","date":"2022-12-24T02:31:09.000Z","updated":"2023-07-10T10:46:04.942Z","comments":true,"path":"api/articles/设计模式-3结构型.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"设计模式-3结构型适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"设计模式","uid":"deffdaaa2a24a19ee257667b3b36743c","slug":"设计模式","date":"2022-12-23T03:22:13.000Z","updated":"2023-07-10T08:08:02.750Z","comments":true,"path":"api/articles/设计模式.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"一、设计模式的六大原则（SOLID）总原则——开闭原则（Open Closed Principle） 一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"设计模式-4行为型","uid":"d9d546a3845e2f02675addd2c83d359c","slug":"设计模式4-行为型","date":"2022-12-25T04:01:46.000Z","updated":"2023-07-10T11:35:40.025Z","comments":true,"path":"api/articles/设计模式4-行为型.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"———————行为型模式———————策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。 定义一...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}}]}