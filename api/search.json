[{"id":"a7c26ccd35ec82da136c0570ee467139","title":"部署hexo","content":"hexo部署\n\n\n\n\n\n\n\n\n官方文档：部署 | Hexo\n1.安装 hexo-deployer-git。cd 项目根目录\nnpm install hexo-deployer-git --save\nnpm list hexo-deployer-git 可以用这个命令查看\n\n2.项目根目录下，找到_config.yml修改_config.yml，如果没改过的话就在最后那里（大概90行，改过的话应该也是90行附近），把\ndeploy:\n\ttype: git\n\trepo: xxx（仓库的ssh）\n\tbranch: master\n#改成这个样子，注意缩进跟空格\n\n3.修改完了之后提交到仓库这里仓库建立原则（如果之前建错了没关系，改成这样就行了）：用户名.github.io\nhexo clean\nhexo d\n执行完了不报错就没问题了，我是报错了😂，我开了魔法，关了再提交就好了，也可能时密码啥的问题，具体看报错信息然后查查看\n\n等提交完成就可以直接访问了 仓库名就行了，游览器会自动转成相应的url\n比如这是我的：首页 | Ushioiu’s Blog (lingdeuxy.github.io)\n4.vercel加速参考：https://www.bilibili.com/video/BV1eG411G736/\n效果：首页 | Ushioiu’s Blog\n","slug":"部署hexo","date":"2023-07-11T09:00:11.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"Ushioiu"},{"id":"bdcd2d68ae9a7e36348f5757efa8e7a8","title":"博客公告","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n公告公告由于之前的博客作者更新了，并且更新之后还没有完善的文档介绍（他的博客也打不开了😂），所有重新用aurora搭建了一个博客，虽然文档是全的，但是需要结合hexo文档一起看，不过这个也断更了，如果后面有机会，自己更新一下吧。\n","slug":"博客公告","date":"2023-06-27T12:40:23.000Z","categories_index":"","tags_index":"公告","author_index":"Ushioiu"},{"id":"c2638a24a5e768209da0531f8abef920","title":"Hexo+Aurora快速搭建-2","content":"快速配置推荐文章配置前面我们已经配置了about页面，关于里面内容后续在添加即可。\n推荐文章注意点\n\n如上图所示，推荐文章部分显示需要有3篇文章时才会生效，如果不够就默认不会显示者一块区域，也可能会影响下面全部文章的显示。\n项目根目录下的_config.aurora.yml里面（大概55行左右）   theme:\n  dark_mode: true # 深色主题\n  profile_shape: diamond # 头像样式 support &#96;circle&#96;, &#96;diamond&#96;, &#96;rounded&#96;\n  feature: true # 推荐模式打开\n  gradient:\n    color_1: &#39;#24c6dc&#39;\n    color_2: &#39;#5433ff&#39;\n    color_3: &#39;#ff0099&#39;\n\n如果开启了推荐文章模式，那么我们需要至少3篇文章，一开始hexo生成了helloword所以我们跟它同等级目录下新建md文件就行。（当然可以使用hexo指令）   \n修改配置文件后需要重启项目（最好clean 然后 build 一下 如下指令）   hexo clean\nhexo g\nhexo s\n\n社交链接配置   socials:\n github: &#39;https:&#x2F;&#x2F;github.com&#x2F;TriDiamond&#39;\n twitter: &#39;&#39;\n stackoverflow: &#39;&#39;\n weibo: &#39;https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7318914058&#39;\n zhihu: &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tridiamond&#39;\n csdn: &#39;https:&#x2F;&#x2F;blog.csdn.net&#x2F;TriDiamond6&#39;\n juejin: &#39;https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;1873223546578589&#39;\n   做完这些，我们这个博客的基本功能已经实现可以发布了，接下来会教大家放到github上面了。\n","slug":"Hexo+Aurora快速搭建-2","date":"2023-06-27T12:27:46.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"Ushioiu"},{"id":"af6a277a1f79cc7652a602f9f57ed64f","title":"Nginx","content":"Nginx详解\n\n\n\n\n\n\n\n\n\n正向代理\n正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。\n正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。\n\n\n\n\n\n\n\n\n\n反向代理\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。\n反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。\n负载均衡Nginx支持的负载均衡调度算法方式如下：\nweight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。\nfair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。\n动静分离为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。\n常用指令\n# 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务\nnginx -s stop\n# 平稳关闭Nginx，保存相关信息，有安排的结束web服务\nnginx -s quit\n# 因改变了Nginx相关配置，需要重新加载配置而重载\nnginx -s reload\n# 重新打开日志文件\nnginx -s reopen\n# 为 Nginx 指定一个配置文件，来代替缺省的\nnginx -c filename\n# 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件\nnginx -t\n#  显示 nginx 的版本\nnginx -v\n# 显示 nginx 的版本，编译器版本和配置参数\nnginx -V\n# 格式换显示 nginx 配置参数\n2&gt;&amp;1 nginx -V | xargs -n1\n2&gt;&amp;1 nginx -V | xargs -n1 | grep lua\n\n为什么使用NginxNginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：\n\nHTTP和HTTPS（TLS &#x2F; SSL &#x2F; SNI）\n超快速的Web服务器用于静态内容\nFastCGI，WSGI，SCGI用于动态内容\n具有负载平衡和缓存功能的加速Web代理\n不间断实时二进制升级和配置\n压缩和内容过滤器\n虚拟主机\nFLV和MP4的媒体流\n带宽和连接策略\n全面的访问控制\n自定义日志\n嵌入式脚本\n带有TLS的SMTP &#x2F; IMAP &#x2F; POP3的邮件代理\n逻辑，灵活，可扩展的配置\n在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行\n\n优势：IO多路复用epoll（IO复用）：如何理解呢？举个例子吧！有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。这个老师C就是Nginx。\n轻量级：\n功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加\n代码模块化 - 更适合二次开发，如阿里巴巴Tengine\n\nCPU亲和：把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。\n配置\n#打开主配置文件，若你是用lnmp环境安装\nvim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf\n\n----------------------------------------\n\nuser                    #设置nginx服务的系统使用用户\nworker_processes        #工作进程数 一般情况与CPU核数保持一致\nerror_log               #nginx的错误日志\npid                     #nginx启动时的pid\n\nevents &#123;\n    worker_connections    #每个进程允许最大连接数\n    use                   #nginx使用的内核模型\n&#125;\n\n我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。\n\nhttp &#123;\n    ... ...        #后面再详细介绍 http 配置项目\n    \n    server &#123;\n        listen 80                          #监听端口;\n        server_name localhost              #地址\n        \n        location &#x2F; &#123;                       #访问首页路径\n            root &#x2F;xxx&#x2F;xxx&#x2F;index.html       #默认目录\n            index index.html index.htm     #默认文件\n        &#125;        \n        \n        error_page  500 504   &#x2F;50x.html    #当出现以上状态码时从新定义到50x.html\n        location &#x3D; &#x2F;50x.html &#123;             #当访问50x.html时\n            root &#x2F;xxx&#x2F;xxx&#x2F;html             #50x.html 页面所在位置\n        &#125;        \n    &#125;\n    \n    server &#123;\n        ... ... \n    &#125; \n&#125;\n\n一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。\n我们再来看看 http 的配置详情\n\nhttp &#123;\n    sendfile  on                  #高效传输文件的模式 一定要开启\n    keepalive_timeout   65        #客户端服务端请求超时时间\n    log_format  main   XXX        #定义日志格式 代号为main\n    access_log  &#x2F;usr&#x2F;local&#x2F;access.log  main     #日志保存地址 格式代码 main\n&#125;\n\n下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。\n\n\n\n\n\n\n\n\n\n\n详情:https://mp.weixin.qq.com/s/XoqGvYBabW8YBl9xEeNYZw\n","slug":"Nginx","date":"2023-07-06T11:02:33.000Z","categories_index":"服务器","tags_index":"Nginx","author_index":"Ushioiu"},{"id":"77f213291e2f36c95ae014c6c6641222","title":"Spring事务传播机制","content":"Spring事务传播机制简单理解，加入A方法在执行中调用B方法，然后A方法事务是否对B方法事务，B方法是否有事务，是否能对A方法事务产生影响，这些都是传播机制决定的。\n7种传播机制● REQUIRED：如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新的事务。这是默认的传播行为。\n● SUPPORTS：如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。\n● MANDATORY：如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常。\n● REQUIRES_NEW：总是创建一个新的事务；如果当前存在事务，则挂起该事务。\n● NOT_SUPPORTED：总是以非事务方式执行；如果当前存在事务，则挂起该事务。\n● NEVER：总是以非事务方式执行；如果当前存在事务，则抛出异常。\n● NESTED：如果当前存在事务，则在该事务的嵌套事务中执行；如果不存在事务，则创建一个新的事务。\n\n重要提示：Spring中事务的默认实现使用的是AOP，也就是代理的方式，如果大家在使用代码测试时，同一个Service类中的方法相互调用需要使用注入的对象来调用，不要直接使用this.方法名来调用，this.方法名调用是对象内部方法调用，不会通过Spring代理，也就是事务不会起作用\nREQUIRED(Spring默认的事务传播类型)如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务\n@Transactional(propagation = Propagation.REQUIRED)\npublic void A()&#123;\n    insertA(a1);  //插入a1数据\n    insertB();   \n&#125;\n@Transactional(propagation = Propagation.REQUIRED)\npublic void insertB()&#123;\n    B(b1); //插入b1数据\n    throw Exception;\n    B(b2);//插入b2数据\n&#125;\n//这时候抛出异常后，因为myMain有事务，所以insertB加入了A事务，数据库不会插入数据\npublic void A()&#123;\n    insertA(a1);  \n    insertB();   \n&#125;\n@Transactional(propagation = Propagation.REQUIRED)\npublic void insertB()&#123;\n    B(b1); \n    throw Exception;\n    B(b2);\n&#125;\n//这样的话，因为A没有事务，所以insertB新建事务，然后异常后回滚自己事务，A中已经插入了a1数据，b1数据没有插入。\n\nSUPPORTS当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行\npublic void A()&#123;\n    insertA(a1);  \n    insertB();   \n&#125;\n@Transactional(propagation = Propagation.SUPPORTS)\npublic void insertB()&#123;\n    B(b1); \n    throw Exception;\n    B(b2);\n&#125;\n//那这里的话，因为A没有事务，所以insertB也不会有事务，最后a1，b1插入了数据库\n\nMANDATORY当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。\npublic void A()&#123;\n    insertA(a1);  \n    insertB();   \n&#125;\n@Transactional(propagation = Propagation.MANDATORY)\npublic void insertB()&#123;\n    B(b1); \n    throw Exception;\n    B(b2);\n&#125;\n// 如事务介绍，这里在调用insertB会抛出异常，a1插入数据库，insertB不会执行\n\nREQUIRES_NEW创建一个新事务，如果存在当前事务，则挂起该事务。\n@Transactional(propagation = Propagation.REQUIRED)\npublic void myMain()&#123;\n    insertA(a1);  //插入a1数据\n    insertB();\n    throw Exception;\n&#125;\n@Transactional(propagation = Propagation.REQUIRES_NEW)//注意一下两个事务不一样\npublic void insertB()&#123;\n    B(b1); //插入b1数据\n    B(b2);//插入b2数据\n&#125;\n// 这里运行到insertB时，挂起myMain事务，然后新建insertB的事务，然后b1，b2没问题，插入数据库了，但是myMain出错，所以事务回滚，a1插入失败\n\nNOT_SUPPORTED始终以非事务方式执行,如果当前存在事务，则挂起当前事务\n@Transactional(propagation = Propagation.REQUIRED)\npublic void myMain()&#123;\n    insertA(a1);  //插入a1数据\n    insertB();   \n&#125;\n@Transactional(propagation = Propagation.NOT_SUPPORTED)\npublic void insertB()&#123;\n    B(b1); \n    throw Exception;\n    B(b2);\n&#125;\n// b1成功插入，a1，b2失败了，insertB没有事务，所以b1插入后异常，a2失败，然后myMain的事务因为异常进行回滚，a1也没成功插入\n\nNEVER不使用事务，如果当前事务存在，则抛出异常\n@Transactional(propagation = Propagation.REQUIRED)\npublic void testMain()&#123;\n    A(a1);  //插入a1\n    testB(); \n&#125;\n@Transactional(propagation = Propagation.NEVER)\npublic void testB()&#123;\n    B(b1);  //插入b1\n    B(b2);  //插入b2\n&#125;\n// testMain有事务，然后testB就会抛出异常，然后testMain回滚，然后没有数据插入数据库。\n\nNESTED如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）\n@Transactional(propagation = Propagation.REQUIRED)\npublic void testMain()&#123;\n    A(a1);  \n    testB();   \n    throw Exception;     \n&#125;\n@Transactional(propagation = Propagation.NESTED)\npublic void testB()&#123;\n    B(b1);  \n    B(b2);  \n&#125;\n// testMain的事务 包含 testB的事务，然后时testMain出错，所以都回滚，没有数据插入\n@Transactional(propagation = Propagation.REQUIRED)\npublic void testMain()&#123;\n    A(a1);  \n    try&#123;\n        testB();    \n    &#125;catch（Exception e)&#123;\n\n    &#125;\n    A(a2);\n&#125;\n@Transactional(propagation = Propagation.NESTED)\npublic void testB()&#123;\n    B(b1);  \n    throw Exception;    \n    B(b2);  \n&#125;\n// 这个例子就是 testB事务出错，所以testB回滚，但是不会影响testMain事务，所以a1，a2会插入，但是b1，b2不会插入。\n\n","slug":"Spring事务传播机制","date":"2023-07-06T07:02:33.000Z","categories_index":"java","tags_index":"事务传播机制","author_index":"Ushioiu"},{"id":"355e4e72c743c63d64d3d438f298fc52","title":"JEECG低代码平台入门","content":"JEECG低代码平台\n\n\n\n\n\n\n\n\n官网：JEECG官方网站 - 基于BPM的低代码开发平台\n一、下载源码标题栏下载按钮或者源码下载 — JEECG低代码开发平台 - 官方网站\n（vue2，vue3咱们都说一下）\n\n环境条件：jdk，mysql，redis，idea\n二、运行源码项目db目录下有个sql,去数据库执行一下\n找到后端项目的响应模块，运行启动类（启动之前改一下yml的数据库，redis，尽量不要改端口之类的）\nvue3项目（需要pnpm）\n（vue2，也是同样操作，注意一下node.js的版本就行了）\n高版本node编译低版本vue会报错（vue3又只能用高版本），所以可以设置一下package.json如下：\n&quot;scripts&quot;: &#123;\n    &quot;pre&quot;: &quot;cnpm install || yarn --registry https:&#x2F;&#x2F;registry.npm.taobao.org || npm install --registry https:&#x2F;&#x2F;registry.npm.taobao.org &quot;,\n    &quot;serve&quot;: &quot;set NODE_OPTIONS&#x3D;--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;,\n    &quot;build:test&quot;: &quot;set NODE_OPTIONS&#x3D;--openssl-legacy-provider &amp;&amp; vue-cli-service build --mode test&quot;,\n    &quot;build&quot;: &quot;set NODE_OPTIONS&#x3D;--openssl-legacy-provider &amp;&amp; vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;set NODE_OPTIONS&#x3D;--openssl-legacy-provider &amp;&amp; vue-cli-service lint&quot;\n  &#125;,\n\n","slug":"JEECG低代码平台入门","date":"2023-07-01T02:01:21.000Z","categories_index":"低代码","tags_index":"JEECG","author_index":"Ushioiu"},{"id":"d89b2fe5b495167a2d209b5600ce7615","title":"hexo+aurora快速搭建","content":"Hexo快速上手ps：如果完全是小白的话，可以先了解使用一下npm（使用过或者知道怎么使用，有一定前端知识就可以看下面的了，如果过程中有什么模糊的词汇，可以先百度看看，要不容易踩坑，都是过来人-0.0-）\n","slug":"Hexo+Aurora快速搭建","date":"2023-06-26T12:32:20.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"Ushioiu"},{"id":"97946a16fb1f65d448ceb90e1204d329","title":"国内开通GPT Plus","content":"一、ChatGPT Plus升级到付费版的ChatGPT Plus好处自然不用说，懂的都懂。比如稳定，无字数限制，不会有错误等等。本文就分享一下本人(以及若干ChatGPT Plus爱好者+群友)亲测有效的ChatGPT Plus付费版升级流程。注册门槛说实话有点高，总结起来其实就下面4个步骤：这里简单说，欧易是港股上市，国内最大的交易所，Depay是最大的虚拟信用卡公司。\n二、实操步骤要完成上述4个步骤，你需要提前准备好：\n\n注册1个可用的ChatGPT账号\n注册1个虚拟交易平台欧易账号(没得选，国内安全的只有它)\n申请1张虚拟信用卡(选Depay，群里小伙伴都是用它)\n能正常访问ChatGPT的科学上网条件（一定要选美国或者欧洲的代理节点）\n\n1、申请ChatGPT账号这一步网上有很多详细的教程，我这里就不细说了。还没有自己的ChatGPT账号的，先参照国内注册一个属于自己的免费ChatGPT账号【附常见问题解决】 一步一步做，申请一个属于自己的ChatGPT，这个教程注册+接验证码都有了，国内的手机号也可以完成注册。照着做就行，只有先搞定ChatGPT账号，才能在此基础上升级到ChatGPT Plus。\n已经有ChatGPT账号的，直接进入第2步，走起！\n2、申请欧易账号完成USDT充值因为Depay不接受人民币直接充值，所以我们必须借助交易所平台，来完成人民币—USDT—USD美元的兑换过程，等Depay账户里有USD美元了再给ChatGPT Plus 充值。这里，对USDT不熟悉的朋友我说一下，USDT是虚拟货币泰达币，跟USD美元锚定的，背后有大而不倒的金融机构担保，只要USD在它就在，安全性不用担心。\n关于交易所，咱国内用户，受前两年国家整顿的政策影响，当下国家支持并且靠谱的大交易所目前就仅剩下欧易一家独大了，咱没得选，乖乖注册一个欧易账号就好。\n点击这里–&gt;跳转官网注册欧易账号\n等待欧易账号注册好，下载并安装APP，安装过程中如果系统提示有安全风险，不必理会，对于虚拟货币，系统都会误报，咱们这是正规官网下载的，哪来的风险，忽略就好。\n如果你是苹果用户，需要使用海外AppleID登录应用商店下载app，关于如何申请一个海外AppleID，这里不做赘述，去知乎上搜一下就有。\n耐心等待欧易App安装成功，点击App首页——我要买币——快捷买币——选USDT——购买至少23USDT(大概￥200)——支持支付宝、微信或者银行卡购买。\n做完上面这一步，就完成人民币——USDT的兑换，也就是上面说的第一步。\n这里，我多买点，买36USDT，大概250人民币。\n\n\n\n\n\n\n\n\n\n\n额外啰嗦一句——虽然你们经常听到身边朋友说谁谁谁炒币炒合约翻了几百倍财富自由了什么的，确有其事。但还是不建议你去炒币，因为风险挺大的，很少人能管住自己的贪欲，确实有人赚钱，但是亏钱的也不少，大家不要轻易尝试。切记！不过，新人注册欧易会送你盲盒，盲盒里有随机币种，大概也能值几USDT，建议卖掉换成USDT。\n3、申请虚拟信用卡Depay\n什么是Depay首先，ChatGPT充值要求必须美国的信用卡，咱们国内的双币卡、全币卡都不能用。不用说，对于国内没有美国当地信用卡的小伙伴，肯定选赫赫有名的Depay美国虚拟信用卡。\n\n注册Depay账号点此注册Depay账号，可以用邮箱或者手机号，我本人选的谷歌邮箱注册，如果验证码没收到很可能在垃圾箱里。账号注册成功后，会让你下载它们的App安装，苹果手机需要登录海外的Apple账号，安卓手机可以直接下载apk安装，我下载的是depay1.2.4.apk版本。耐心等待APP安装完毕，用刚刚注册的账号和密码登录Depay。\n\n申请第一张卡点击界面左上角的“申请卡”开通虚拟信用卡，开卡的时候可以选0开卡费的，也可以选10USDT开卡费(一次性)的，区别是0开卡费的需要你完成KYC认证，通俗点说就是需要你上传身份证(国内身份证没问题)或者护照认证，如果你暂时不想上传自己身份证或者护照实名的话，可以先选10USDT开卡费的，这样，下面你就要记得多转10USDT。 高级卡、白金卡有10U和50U的开卡费，自己决定要不要开通，区别在于月费、手续费和额度。开通后不要急着注销，因为注销了后再开卡要10U开卡费，你后面充值chatgpt plus还是要用的，建议是把Depay卡当做普通的信用卡用。\n不得不说，拥有一张Depay虚拟信用卡在线上支付方面还是很方便的，它支持绑定支付宝、微信支付、美团外卖、拼多多、Paypal、天猫国际版，苹果美区商店等，具体你们可以去搜一下”Depay作用”。关于Depay的任何使用问题，都可以去Depay官方电报群反馈(需要科学访问)。卡开通后，可以往Depay里充值USDT ，这一步在接下去的第4小章节会讲到，需要用到前面注册的欧易账号来充值USDT。\n\n\n\n这里忍不住安利一下， Depay平常可以用于微信，支付宝，美团消费，直接用USDT做日常小额消费，还免收手续费，这还是很舒服的。关于这方面，花几分钟看下这篇文章《Depay虚拟卡绑定ChatGPT以及微信、支付宝等使用场景和建议》，这里放1张截图，其他的不做过多阐述。\n4、给钱包充值USDT1、 打开Depay App钱包，找到钱包——USDT——充币——复制你的充值地址，确认屏幕上显示主网是TRC20，充值地址千万不要复制错，比如我的Depay钱包的USDT充值地址是TKeiEjFBDyJTAb89YhFDQCyFfLjiZJt55Z。\n\n2、 打开上面第2步注册的欧易App，找到首页——资产——提币——USDT——链上提币。提币地址填Depay钱包里的充值地址，这里我填TKeiEjFBDyJTAb89YhFDQCyFfLjiZJt55Z，提币网络选TRC20 (千万不能选错，否则到不了账)，数量选大于23USDT就行，够充值1个月ChatGPT Plus会员就行。提交，等待到账。\n\n3、欧易提现到Depay成功后，点击Depay App钱包——兑换，将所有的USDT都兑换成USD美元\n\n4、点击Depay App首页的To Card，将兑换的美元存入卡中，到此，Depay充值大功告成。\n📢📢📢注意需要注意的是，新注册的欧易用户默认完成身份认证后，需要等待24小时才可以提现，如果你着急提现到Depay，你可以尝试找一下人工客服，说下你的诉求，据群友反馈，有一定概率可以解除24小时等待。万一你真的特别着急，你也可以去微博上找depay代充，一般对方会按照汇率1:8收点劳务费。不是很急的话建议24小时就行，不必花这冤枉钱。\n三、开通ChatGPT Plus我们已经在第3步中拥有了一张属于自己的虚拟信用卡(其实相当于借记卡，不可透支)，并且往里面充了20多美刀，够我们订阅1个月ChatGPT Plus了。登录ChatGPT, 左下角找到升级Plus的选项——Upgrade to Plus\n\n一些群友反馈没有出现这个升级的选项，记得把IP切换到美国或者欧洲再重新登陆，现阶段只有美国或欧洲的IP才会有这个选项，(升级的时候需要国际IP，升级完毕后不要求)。\n另外，切记切记——\n\n科学上网，尽量用美国或者欧洲IP\n浏览器开启无痕模式\n账单地址用美国地址生成器生成\n如果1、2都做了还是失败，那么尝试清空浏览器缓存，无痕登录，重新登录ChatGPT再尝试。如果还是不行，那么建议更换你目前在用的代理节点再试，直到成功。\n\n关于代理代理一定要用美国或欧洲的IP，特别是香港的IP已经不行了。如果你不确定自己的IP是不是美国或欧洲的，http://en.ipip.net/ 查看。不要用那种很多人使用的代理，容易失败。如果你自己的代理被别人污染了，我这里推荐用batvpn，目前使用的人还不多，ip还算纯净。\n关于账单地址理论上随便填都行，你可以网上搜美国地址生成器，直接生成一个免税州的账单地址:\n请一定要用美国或者欧洲的IP访问，不行的话多切几个节点试验，否则可能会遇到如下报错，这里没有其他办法。\n\n四、ChatGPT Plus初体验看到如下PLUS的尊贵标识，就说明你已经成功开通ChatGPT Plus了。只能说，这钱花的值，你将拥有了AI的丝滑体验。\n每个月大概不到￥150，也就3杯星巴克的钱，换来的是一个高效的信息获取渠道，不亏，是一个跨时代的生产力。\n至此，恭喜您，已经成为了尊贵的ChatGPT Plus用户，成为全球走在时代前沿的人了。从现在起，访问ChatGPT Plus就拥有Default和Legacy双模型回答，以及快速、稳定的AI回复。\n\n五、常见问题&amp;解决这里汇总了群友最常遇到的一些问题及解决办法如下——\n\n如何取消ChatGPT Plus的自动订阅？\n\n\n\n\n\n\n\n\n\n上面说过，我们的Depay信用卡其实没有透支功能，只是相当于借记卡，理论上说只要你不往卡里充钱，其实不必担心下个月被扣款。不过，保险起见，你还是可以取消自动订阅，方法是：打开ChatGPT首页并登录——左下角——My Account——Manage My Subscription——Cancel Plan\n\nChatGPT Plus中的default mode和legacy mode有什么区别？\n\n\n\n\n\n\n\n\n\ndefault mode就是Turbo mode，它会更有情感和活力，会有趣一些，不过回答上偏更加简洁，省去了之前legacy mode一些细节。legacy mode则更适合学术论文，不像Turbo Mode回答那么大众，适合科研，论文。更详细的比较可以参考：https://www.reddit.com/r/ChatGPT/comments/111skny/the_differences_between_default_and_legacy_models/\n\n信用卡被拒，提示：”你的信用卡被拒绝了，请尝试用借记卡支付“\n\n\n\n\n\n\n\n\n\n信用卡被拒可能有以下几个原因：你的信用卡确实不支持，比 Depay 的虚拟信用卡的号段被 OpenAI&#x2F;ChatGPT 拒绝。可以尝试更换虚拟信用卡，Depay 支持申请多张。你的网络环境被 Stripe 风控，挂全局代理 + 浏览器无痕模式再试，总之挂代理和不挂代理都试一下全局代理 + 浏览器无痕模式 + 更换 IP 失败次数超过 3-5 次，不建议继续尝试，这种情况可以考虑更换 ChatGPT 账号 + 无痕 + 更换梯子重新订阅试试。\n\n为什么升级到ChatGPT Plus需要这么麻烦？\n\n\n\n\n\n\n\n\n\n这个问题归根结底是因为openAI不支持PayPal充值，大家没事就写 e-mail给openai的ceoSam Altman(国人喊他奥特曼)，让他早点支持支持payPal吧。\n\n升级ChatGPT Plus每个月$20值不值？\n\n\n\n\n\n\n\n\n\n这是一个仁者见仁智者见智的问题，你觉得值它就值，你觉得不值，就尝试下取消续费就好。不过，应该没人会拒绝更优越的生产力吧？\n\n\n\n\n\n\n\n\n提示\n因为之前自己用的时候找了好久，这篇写的很详细了，所以拉过来。转载：https://chatgpt-plus.github.io/chatgpt-plus/\n\n","slug":"国内开通GPT","date":"2023-05-20T12:28:49.000Z","categories_index":"AI","tags_index":"GPT","author_index":"Ushioiu"},{"id":"d9d546a3845e2f02675addd2c83d359c","title":"设计模式-4行为型","content":"———————行为型模式———————策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。\n定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。\n\n\n\n\n\n\n\n\n\n应用实例：1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略；2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。\n\ncode\n// 策略接口\ninterface Strategy &#123;\n    void executeStrategy(int num1, int num2);\n&#125;\n\n// 具体策略类A\nclass ConcreteStrategyA implements Strategy &#123;\n    public void executeStrategy(int num1, int num2) &#123;\n        int result = num1 + num2;\n        System.out.println(\"Strategy A: \" + result);\n    &#125;\n&#125;\n\n// 具体策略类B\nclass ConcreteStrategyB implements Strategy &#123;\n    public void executeStrategy(int num1, int num2) &#123;\n        int result = num1 - num2;\n        System.out.println(\"Strategy B: \" + result);\n    &#125;\n&#125;\n\n// 具体策略类C\nclass ConcreteStrategyC implements Strategy &#123;\n    public void executeStrategy(int num1, int num2) &#123;\n        int result = num1 * num2;\n        System.out.println(\"Strategy C: \" + result);\n    &#125;\n&#125;\n\n// 上下文类\nclass Context &#123;\n    private Strategy strategy;\n\n    public Context(Strategy strategy) &#123;\n        this.strategy = strategy;\n    &#125;\n\n    public void setStrategy(Strategy strategy) &#123;\n        this.strategy = strategy;\n    &#125;\n\n    public void executeStrategy(int num1, int num2) &#123;\n        strategy.executeStrategy(num1, num2);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Context context = new Context(new ConcreteStrategyA());\n        context.executeStrategy(5, 2);\n\n        context.setStrategy(new ConcreteStrategyB());\n        context.executeStrategy(5, 2);\n\n        context.setStrategy(new ConcreteStrategyC());\n        context.executeStrategy(5, 2);\n    &#125;\n&#125;\n\n\n\n模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n\n\n\n\n\n\n\n\n应用实例：1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架；3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\ncode\n// 抽象模板类\nabstract class AbstractClass &#123;\n    public void templateMethod() &#123;\n        primitiveOperation1();\n        primitiveOperation2();\n        concreteOperation();\n        hook(); // 钩子方法，子类可以选择实现\n    &#125;\n\n    protected abstract void primitiveOperation1();\n    protected abstract void primitiveOperation2();\n\n    private void concreteOperation() &#123;\n        System.out.println(\"Concrete operation\");\n    &#125;\n\n    protected void hook() &#123; \n        // 默认为空实现\n    &#125;\n&#125;\n\n// 具体模板类A\nclass ConcreteClassA extends AbstractClass &#123;\n    protected void primitiveOperation1() &#123;\n        System.out.println(\"ConcreteClassA primitive operation 1\");\n    &#125;\n\n    protected void primitiveOperation2() &#123;\n        System.out.println(\"ConcreteClassA primitive operation 2\");\n    &#125;\n&#125;\n\n// 具体模板类B\nclass ConcreteClassB extends AbstractClass &#123;\n    protected void primitiveOperation1() &#123;\n        System.out.println(\"ConcreteClassB primitive operation 1\");\n    &#125;\n\n    protected void primitiveOperation2() &#123;\n        System.out.println(\"ConcreteClassB primitive operation 2\");\n    &#125;\n\n    protected void hook() &#123;\n        System.out.println(\"ConcreteClassB hook implementation\");\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        AbstractClass classA = new ConcreteClassA();\n        classA.templateMethod();\n\n        System.out.println(\"------\");\n\n        AbstractClass classB = new ConcreteClassB();\n        classB.templateMethod();\n    &#125;\n&#125;\n\n\n\n观察者模式当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n\n\n\n\n\n\n\n\n应用实例：1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价；2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n\ncode\n// 观察者接口\ninterface Observer &#123;\n    void update(String message);\n&#125;\n\n// 被观察者接口\ninterface Subject &#123;\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers(String message);\n&#125;\n\n// 具体被观察者类\nclass ConcreteSubject implements Subject &#123;\n    private List&lt;Observer> observers;\n    private String message;\n\n    public ConcreteSubject() &#123;\n        observers = new ArrayList&lt;>();\n    &#125;\n\n    public void attach(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    public void detach(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    public void notifyObservers(String message) &#123;\n        this.message = message;\n        for (Observer observer : observers) &#123;\n            observer.update(message);\n        &#125;\n    &#125;\n\n    public void setMessage(String message) &#123;\n        this.message = message;\n        notifyObservers(message);\n    &#125;\n&#125;\n\n// 具体观察者类\nclass ConcreteObserver implements Observer &#123;\n    private String name;\n\n    public ConcreteObserver(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void update(String message) &#123;\n        System.out.println(name + \" received message: \" + message);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建被观察者和观察者对象\n        ConcreteSubject subject = new ConcreteSubject();\n        ConcreteObserver observer1 = new ConcreteObserver(\"Observer 1\");\n        ConcreteObserver observer2 = new ConcreteObserver(\"Observer 2\");\n\n        // 注册观察者\n        subject.attach(observer1);\n        subject.attach(observer2);\n\n        // 被观察者发送通知\n        subject.setMessage(\"Hello World!\");\n    &#125;\n&#125;\n\n\n\n迭代器模式迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n迭代器模式属于行为型模式。\n提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\n\n\n\n\n\n\n\n应用实例：JAVA中的iterator。\n\ncode\n// 迭代器接口\ninterface Iterator &#123;\n    boolean hasNext();\n    Object next();\n&#125;\n\n// 聚合对象接口\ninterface Aggregate &#123;\n    Iterator createIterator();\n&#125;\n\n// 具体聚合对象\nclass ConcreteAggregate implements Aggregate &#123;\n    private Object[] elements;\n    private int length;\n\n    public ConcreteAggregate(int capacity) &#123;\n        elements = new Object[capacity];\n        length = 0;\n    &#125;\n\n    public void add(Object element) &#123;\n        if (length &lt; elements.length) &#123;\n            elements[length++] = element;\n        &#125;\n    &#125;\n\n    public Object get(int index) &#123;\n        if (index >= 0 &amp;&amp; index &lt; length) &#123;\n            return elements[index];\n        &#125;\n        return null;\n    &#125;\n\n    public int size() &#123;\n        return length;\n    &#125;\n\n    public Iterator createIterator() &#123;\n        return new ConcreteIterator(this);\n    &#125;\n&#125;\n\n// 具体迭代器\nclass ConcreteIterator implements Iterator &#123;\n    private ConcreteAggregate aggregate;\n    private int index;\n\n    public ConcreteIterator(ConcreteAggregate aggregate) &#123;\n        this.aggregate = aggregate;\n        index = 0;\n    &#125;\n\n    public boolean hasNext() &#123;\n        return index &lt; aggregate.size();\n    &#125;\n\n    public Object next() &#123;\n        if (hasNext()) &#123;\n            return aggregate.get(index++);\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建聚合对象并添加元素\n        ConcreteAggregate aggregate = new ConcreteAggregate(5);\n        aggregate.add(\"Element 1\");\n        aggregate.add(\"Element 2\");\n        aggregate.add(\"Element 3\");\n        aggregate.add(\"Element 4\");\n        aggregate.add(\"Element 5\");\n\n        // 获取迭代器并遍历聚合对象\n        Iterator iterator = aggregate.createIterator();\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n&#125;\n\n\n\n责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。\n在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n\n\n\n\n\n\n\n\n\n应用实例：红楼梦中的”击鼓传花”。\n\ncode\n// 请求类\nclass Request &#123;\n    private String content;\n\n    public Request(String content) &#123;\n        this.content = content;\n    &#125;\n\n    public String getContent() &#123;\n        return content;\n    &#125;\n&#125;\n\n// 处理者抽象类\nabstract class Handler &#123;\n    private Handler nextHandler;\n\n    public void setNextHandler(Handler nextHandler) &#123;\n        this.nextHandler = nextHandler;\n    &#125;\n\n    public void handleRequest(Request request) &#123;\n        if (canHandle(request)) &#123;\n            processRequest(request);\n        &#125; else if (nextHandler != null) &#123;\n            nextHandler.handleRequest(request);\n        &#125; else &#123;\n            System.out.println(\"No handler can process the request.\");\n        &#125;\n    &#125;\n\n    protected abstract boolean canHandle(Request request);\n    protected abstract void processRequest(Request request);\n&#125;\n\n// 具体处理者A\nclass ConcreteHandlerA extends Handler &#123;\n    protected boolean canHandle(Request request) &#123;\n        // 具体判断逻辑\n        return request.getContent().startsWith(\"A\");\n    &#125;\n\n    protected void processRequest(Request request) &#123;\n        System.out.println(\"ConcreteHandlerA handles the request: \" + request.getContent());\n    &#125;\n&#125;\n\n// 具体处理者B\nclass ConcreteHandlerB extends Handler &#123;\n    protected boolean canHandle(Request request) &#123;\n        // 具体判断逻辑\n        return request.getContent().startsWith(\"B\");\n    &#125;\n\n    protected void processRequest(Request request) &#123;\n        System.out.println(\"ConcreteHandlerB handles the request: \" + request.getContent());\n    &#125;\n&#125;\n\n// 具体处理者C\nclass ConcreteHandlerC extends Handler &#123;\n    protected boolean canHandle(Request request) &#123;\n        // 具体判断逻辑\n        return request.getContent().startsWith(\"C\");\n    &#125;\n\n    protected void processRequest(Request request) &#123;\n        System.out.println(\"ConcreteHandlerC handles the request: \" + request.getContent());\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建处理者对象\n        Handler handlerA = new ConcreteHandlerA();\n        Handler handlerB = new ConcreteHandlerB();\n        Handler handlerC = new ConcreteHandlerC();\n\n        // 设置处理顺序，构成处理链\n        handlerA.setNextHandler(handlerB);\n        handlerB.setNextHandler(handlerC);\n\n        // 创建请求并发送\n        Request request1 = new Request(\"A123\");\n        handlerA.handleRequest(request1);\n\n        Request request2 = new Request(\"B456\");\n        handlerA.handleRequest(request2);\n\n        Request request3 = new Request(\"C789\");\n        handlerA.handleRequest(request3);\n\n        Request request4 = new Request(\"D123\");\n        handlerA.handleRequest(request4);\n    &#125;\n&#125;\n\n\n\n命令模式命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n\n\n\n\n\n\n\n\n\n应用实例：电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。\n\ncode\n// 命令接口\ninterface Command &#123;\n    void execute();\n&#125;\n\n// 具体命令\nclass ConcreteCommand implements Command &#123;\n    private Receiver receiver;\n\n    public ConcreteCommand(Receiver receiver) &#123;\n        this.receiver = receiver;\n    &#125;\n\n    public void execute() &#123;\n        receiver.action();\n    &#125;\n&#125;\n\n// 命令接收者\nclass Receiver &#123;\n    public void action() &#123;\n        System.out.println(\"Receiver performs the action\");\n    &#125;\n&#125;\n\n// 命令发送者\nclass Invoker &#123;\n    private Command command;\n\n    public void setCommand(Command command) &#123;\n        this.command = command;\n    &#125;\n\n    public void executeCommand() &#123;\n        command.execute();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建命令接收者\n        Receiver receiver = new Receiver();\n\n        // 创建具体命令，将命令接收者传入\n        Command command = new ConcreteCommand(receiver);\n\n        // 创建命令发送者并设置命令\n        Invoker invoker = new Invoker();\n        invoker.setCommand(command);\n\n        // 命令发送者执行命令\n        invoker.executeCommand();\n    &#125;\n&#125;\n\n\n\n备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n\n\n\n\n\n\n\n\n\n应用实例：1、后悔药；2、打游戏时的存档；3、Windows里的ctri+z；4、IE中的后退；5、数据库的事务管理。\n\ncode\n// 备忘录\nclass Memento &#123;\n    private String state;\n\n    public Memento(String state) &#123;\n        this.state = state;\n    &#125;\n\n    public String getState() &#123;\n        return state;\n    &#125;\n&#125;\n\n// 原始对象\nclass Originator &#123;\n    private String state;\n\n    public void setState(String state) &#123;\n        this.state = state;\n    &#125;\n\n    public String getState() &#123;\n        return state;\n    &#125;\n\n    public Memento createMemento() &#123;\n        return new Memento(state);\n    &#125;\n\n    public void restoreFromMemento(Memento memento) &#123;\n        state = memento.getState();\n    &#125;\n&#125;\n\n// 管理者\nclass Caretaker &#123;\n    private Memento memento;\n\n    public void saveMemento(Memento memento) &#123;\n        this.memento = memento;\n    &#125;\n\n    public Memento retrieveMemento() &#123;\n        return memento;\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建原始对象和管理者\n        Originator originator = new Originator();\n        Caretaker caretaker = new Caretaker();\n\n        // 原始对象设置状态\n        originator.setState(\"State 1\");\n\n        // 原始对象保存状态到备忘录\n        Memento memento = originator.createMemento();\n        caretaker.saveMemento(memento);\n\n        // 原始对象修改状态\n        originator.setState(\"State 2\");\n\n        // 原始对象从备忘录恢复状态\n        Memento savedMemento = caretaker.retrieveMemento();\n        originator.restoreFromMemento(savedMemento);\n\n        // 恢复后的状态\n        System.out.println(\"Restored state: \" + originator.getState());\n    &#125;\n&#125;\n\n\n\n状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。\n在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。\n允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n\n\n\n\n\n\n\n\n\n应用实例：1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态；2、曾侯乙编钟中，’钟是抽象接口’，’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。\n\ncode\n//在状态模式中，有三个关键角色：上下文/环境（Context/Context）、状态接口（State）和具体状态（Concrete State）。上下文是拥有状态的对象，它将某个请求委派给当前状态对象来处理。状态接口定义了状态的行为。具体状态实现了状态接口，实现了状态的具体行为。\n// 状态接口\ninterface State &#123;\n    void handle(Context context);\n&#125;\n\n// 具体状态A\nclass ConcreteStateA implements State &#123;\n    public void handle(Context context) &#123;\n        System.out.println(\"Handle request in ConcreteStateA\");\n        // 改变状态为具体状态B\n        context.setState(new ConcreteStateB());\n    &#125;\n&#125;\n\n// 具体状态B\nclass ConcreteStateB implements State &#123;\n    public void handle(Context context) &#123;\n        System.out.println(\"Handle request in ConcreteStateB\");\n        // 改变状态为具体状态A\n        context.setState(new ConcreteStateA());\n    &#125;\n&#125;\n\n// 上下文\nclass Context &#123;\n    private State state;\n\n    public Context() &#123;\n        // 初始状态为具体状态A\n        state = new ConcreteStateA();\n    &#125;\n\n    public void setState(State state) &#123;\n        this.state = state;\n    &#125;\n\n    public void request() &#123;\n        state.handle(this);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建上下文\n        Context context = new Context();\n\n        // 发起请求，初始状态为具体状态A\n        context.request();\n\n        // 发起请求，状态变为具体状态B\n        context.request();\n\n        // 发起请求，状态再次变为具体状态A\n        context.request();\n    &#125;\n&#125;\n\n\n\n访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。\n主要将数据结构与数据操作分离。\n主要解决：稳定的数据结构和易变的操作耦合问题。\n\n\n\n\n\n\n\n\n\n应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。\n\ncode\n// 访问者接口\ninterface Visitor &#123;\n    void visit(ElementA elementA);\n    void visit(ElementB elementB);\n&#125;\n\n// 具体访问者\nclass ConcreteVisitor implements Visitor &#123;\n    public void visit(ElementA elementA) &#123;\n        System.out.println(\"Visit ElementA\");\n    &#125;\n\n    public void visit(ElementB elementB) &#123;\n        System.out.println(\"Visit ElementB\");\n    &#125;\n&#125;\n\n// 元素接口\ninterface Element &#123;\n    void accept(Visitor visitor);\n&#125;\n\n// 具体元素A\nclass ElementA implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n\n    public String getElementAInfo() &#123;\n        return \"ElementA Info\";\n    &#125;\n&#125;\n\n// 具体元素B\nclass ElementB implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n\n    public String getElementBInfo() &#123;\n        return \"ElementB Info\";\n    &#125;\n&#125;\n\n// 对象结构\nclass ObjectStructure &#123;\n    private List&lt;Element> elements = new ArrayList&lt;>();\n\n    public void addElement(Element element) &#123;\n        elements.add(element);\n    &#125;\n\n    public void removeElement(Element element) &#123;\n        elements.remove(element);\n    &#125;\n\n    public void accept(Visitor visitor) &#123;\n        for (Element element : elements) &#123;\n            element.accept(visitor);\n        &#125;\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建具体元素\n        Element elementA = new ElementA();\n        Element elementB = new ElementB();\n\n        // 添加元素到对象结构\n        ObjectStructure objectStructure = new ObjectStructure();\n        objectStructure.addElement(elementA);\n        objectStructure.addElement(elementB);\n\n        // 创建具体访问者\n        Visitor visitor = new ConcreteVisitor();\n\n        // 对象结构接受访问者访问\n        objectStructure.accept(visitor);\n    &#125;\n&#125;\n\n\n\n中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。\n用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n\n\n\n\n\n\n\n\n应用实例：1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易；2、机场调度系统；3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。\n\ncode\n// 中介者接口\ninterface Mediator &#123;\n    void send(String message, Colleague colleague);\n&#125;\n\n// 具体中介者\nclass ConcreteMediator implements Mediator &#123;\n    private Colleague colleagueA;\n    private Colleague colleagueB;\n\n    public void setColleagueA(Colleague colleagueA) &#123;\n        this.colleagueA = colleagueA;\n    &#125;\n\n    public void setColleagueB(Colleague colleagueB) &#123;\n        this.colleagueB = colleagueB;\n    &#125;\n\n    public void send(String message, Colleague colleague) &#123;\n        if (colleague == colleagueA) &#123;\n            colleagueB.receive(message);\n        &#125; else if (colleague == colleagueB) &#123;\n            colleagueA.receive(message);\n        &#125;\n    &#125;\n&#125;\n\n// 同事接口\ninterface Colleague &#123;\n    void send(String message);\n    void receive(String message);\n&#125;\n\n// 具体同事A\nclass ConcreteColleagueA implements Colleague &#123;\n    private Mediator mediator;\n\n    public ConcreteColleagueA(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void send(String message) &#123;\n        mediator.send(message, this);\n    &#125;\n\n    public void receive(String message) &#123;\n        System.out.println(\"ConcreteColleagueA received: \" + message);\n    &#125;\n&#125;\n\n// 具体同事B\nclass ConcreteColleagueB implements Colleague &#123;\n    private Mediator mediator;\n\n    public ConcreteColleagueB(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void send(String message) &#123;\n        mediator.send(message, this);\n    &#125;\n\n    public void receive(String message) &#123;\n        System.out.println(\"ConcreteColleagueB received: \" + message);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 创建具体中介者\n        ConcreteMediator mediator = new ConcreteMediator();\n\n        // 创建具体同事A和具体同事B，并设置中介者\n        Colleague colleagueA = new ConcreteColleagueA(mediator);\n        Colleague colleagueB = new ConcreteColleagueB(mediator);\n\n        // 将同事对象设置给中介者\n        mediator.setColleagueA(colleagueA);\n        mediator.setColleagueB(colleagueB);\n\n        // 同事A发送消息给同事B\n        colleagueA.send(\"Hello!\");\n\n        // 同事B发送消息给同事A\n        colleagueB.send(\"Hi!\");\n    &#125;\n&#125;\n\n\n\n解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。\n给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n\n\n\n\n\n\n\n\n\n应用实例：编译器、运算表达式计算。\n\ncode\n// 抽象表达式接口\ninterface Expression &#123;\n    int interpret(Context context);\n&#125;\n\n// 终结表达式类\nclass Number implements Expression &#123;\n    private int value;\n    \n    public Number(int value) &#123;\n        this.value = value;\n    &#125;\n    \n    public int interpret(Context context) &#123;\n        return value;\n    &#125;\n&#125;\n\n// 非终结表达式类 - 加法\nclass Add implements Expression &#123;\n    private Expression left;\n    private Expression right;\n    \n    public Add(Expression left, Expression right) &#123;\n        this.left = left;\n        this.right = right;\n    &#125;\n    \n    public int interpret(Context context) &#123;\n        return left.interpret(context) + right.interpret(context);\n    &#125;\n&#125;\n\n// 上下文类\nclass Context &#123;\n    private Map&lt;String, Integer> variables = new HashMap&lt;>();\n    \n    public void setVariable(String variable, int value) &#123;\n        variables.put(variable, value);\n    &#125;\n    \n    public int getVariable(String variable) &#123;\n        return variables.get(variable);\n    &#125;\n&#125;\n\n// 客户端代码\npublic class InterpreterExample &#123;\n    public static void main(String[] args) &#123;\n        Context context = new Context();\n        \n        Expression expression = new Add(new Number(5), new Number(10));  // 构建表达式：5 + 10\n        \n        int result = expression.interpret(context);  // 解释并求值\n        \n        System.out.println(\"Result: \" + result);\n    &#125;\n&#125;\n\n\n\n","slug":"设计模式4-行为型","date":"2022-12-25T04:01:46.000Z","categories_index":"java","tags_index":"设计模式","author_index":"Ushioiu"},{"id":"76ea06e5385949b20227d2bc700d9a86","title":"设计模式-3结构型","content":"设计模式-3结构型适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。\n这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。\n将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n适配器模式常被用于以下场景：\n\n当需要使用一个已经存在的类，但其接口不符合需要时，可以使用适配器模式将其接口转换为符合需求的接口。\n当希望复用某个类，但是由于其接口与其他类不兼容时，可以创建一个适配器来充当两者之间的桥梁。\n\n\n\n\n\n\n\n\n\n\n应用实例：1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡；2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。\n\ncode\n// 目标接口\ninterface Target &#123;\n    void request();\n&#125;\n\n// 适配者类\nclass Adaptee &#123;\n    public void specificRequest() &#123;\n        System.out.println(\"Specific request\");\n    &#125;\n&#125;\n\n// 类适配器\nclass ClassAdapter extends Adaptee implements Target &#123;\n    @Override\n    public void request() &#123;\n        specificRequest();\n    &#125;\n&#125;\n\n// 对象适配器\nclass ObjectAdapter implements Target &#123;\n    private Adaptee adaptee;\n\n    public ObjectAdapter(Adaptee adaptee) &#123;\n        this.adaptee = adaptee;\n    &#125;\n\n    @Override\n    public void request() &#123;\n        adaptee.specificRequest();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 使用类适配器\n        Target classAdapter = new ClassAdapter();\n        classAdapter.request();\n\n        // 使用对象适配器\n        Adaptee adaptee = new Adaptee();\n        Target objectAdapter = new ObjectAdapter(adaptee);\n        objectAdapter.request();\n    &#125;\n&#125;\n\n\n\n装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n\n\n\n\n\n\n\n\n\n应用实例：1、孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；2、将一个形状装饰上不同的颜色，同时又不改变形状。\n\ncode\n// 组件接口\ninterface Component &#123;\n    void operation();\n&#125;\n\n// 具体组件类\nclass ConcreteComponent implements Component &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteComponent operation\");\n    &#125;\n&#125;\n\n// 抽象装饰器类\nabstract class Decorator implements Component &#123;\n    protected Component component;\n\n    public Decorator(Component component) &#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        component.operation();\n    &#125;\n&#125;\n\n// 具体装饰器类A\nclass ConcreteDecoratorA extends Decorator &#123;\n    public ConcreteDecoratorA(Component component) &#123;\n        super(component);\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        super.operation();\n        System.out.println(\"ConcreteDecoratorA operation\");\n    &#125;\n&#125;\n\n// 具体装饰器类B\nclass ConcreteDecoratorB extends Decorator &#123;\n    public ConcreteDecoratorB(Component component) &#123;\n        super(component);\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        super.operation();\n        System.out.println(\"ConcreteDecoratorB operation\");\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Component component = new ConcreteComponent();\n        component.operation();\n\n        System.out.println(\"------\");\n\n        Component decoratedComponentA = new ConcreteDecoratorA(component);\n        decoratedComponentA.operation();\n\n        System.out.println(\"------\");\n\n        Component decoratedComponentB = new ConcreteDecoratorB(decoratedComponentA);\n        decoratedComponentB.operation();\n    &#125;\n&#125;\n\n\n\n代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n为其他对象提供一种代理以控制对这个对象的访问。\n\n\n\n\n\n\n\n\n\n应用实例：1、Windows里面的快捷方式；2、买火车票不一定在火车站买，也可以去代售点；3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；4、Spring AOP。\n注意事项：\n1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。\n2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\ncode\n// 目标接口\ninterface Subject &#123;\n    void request();\n&#125;\n\n// 目标类\nclass RealSubject implements Subject &#123;\n    @Override\n    public void request() &#123;\n        System.out.println(\"RealSubject request\");\n    &#125;\n&#125;\n\n// 代理类\nclass Proxy implements Subject &#123;\n    private RealSubject realSubject;\n\n    public Proxy(RealSubject realSubject) &#123;\n        this.realSubject = realSubject;\n    &#125;\n\n    @Override\n    public void request() &#123;\n        // 在调用目标对象前可以执行其他操作\n        System.out.println(\"Proxy preRequest\");\n\n        // 调用目标对象的方法\n        realSubject.request();\n\n        // 在调用目标对象后可以执行其他操作\n        System.out.println(\"Proxy postRequest\");\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        RealSubject realSubject = new RealSubject();\n        Subject proxy = new Proxy(realSubject);\n\n        proxy.request();\n    &#125;\n&#125;\n\n\n\n外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。\n为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n\n\n\n\n\n\n\n\n应用实例：去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。\n外观模式适用于以下场景：\n\n当需要使用一个复杂子系统的一部分功能时，可以通过外观类提供的接口进行调用，避免了直接访问子系统的复杂性。\n当需要将子系统与客户端之间解耦，使得系统更加灵活和可维护时，可以使用外观模式。\n\n\ncode\n// 子系统A\nclass SubsystemA &#123;\n    public void operationA() &#123;\n        System.out.println(\"SubsystemA operation\");\n    &#125;\n&#125;\n\n// 子系统B\nclass SubsystemB &#123;\n    public void operationB() &#123;\n        System.out.println(\"SubsystemB operation\");\n    &#125;\n&#125;\n\n// 外观类\nclass Facade &#123;\n    private SubsystemA subsystemA;\n    private SubsystemB subsystemB;\n\n    public Facade() &#123;\n        subsystemA = new SubsystemA();\n        subsystemB = new SubsystemB();\n    &#125;\n\n    public void operation() &#123;\n        subsystemA.operationA();\n        subsystemB.operationB();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Facade facade = new Facade();\n        facade.operation();\n    &#125;\n&#125;\n\n\n\n桥接模式桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。\n这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。\n将抽象部分与实现部分分离，使它们都可以独立的变化。\n又称为柄体（Handle and Body）模式或接口（Interface）模式。\n\n\n\n\n\n\n\n\n\n应用实例：1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择；2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。\n注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。\n\ncode\n// 抽象部分\nabstract class Abstraction &#123;\n    protected Implementor implementor;\n\n    public Abstraction(Implementor implementor) &#123;\n        this.implementor = implementor;\n    &#125;\n\n    public abstract void operation();\n&#125;\n\n// 具体抽象部分A\nclass ConcreteAbstractionA extends Abstraction &#123;\n    public ConcreteAbstractionA(Implementor implementor) &#123;\n        super(implementor);\n    &#125;\n\n    public void operation() &#123;\n        System.out.println(\"ConcreteAbstractionA operation\");\n        implementor.operationImpl();\n    &#125;\n&#125;\n\n// 具体抽象部分B\nclass ConcreteAbstractionB extends Abstraction &#123;\n    public ConcreteAbstractionB(Implementor implementor) &#123;\n        super(implementor);\n    &#125;\n\n    public void operation() &#123;\n        System.out.println(\"ConcreteAbstractionB operation\");\n        implementor.operationImpl();\n    &#125;\n&#125;\n\n// 实现部分\ninterface Implementor &#123;\n    void operationImpl();\n&#125;\n\n// 具体实现部分A\nclass ConcreteImplementorA implements Implementor &#123;\n    public void operationImpl() &#123;\n        System.out.println(\"ConcreteImplementorA operationImpl\");\n    &#125;\n&#125;\n\n// 具体实现部分B\nclass ConcreteImplementorB implements Implementor &#123;\n    public void operationImpl() &#123;\n        System.out.println(\"ConcreteImplementorB operationImpl\");\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Implementor implementorA = new ConcreteImplementorA();\n        Implementor implementorB = new ConcreteImplementorB();\n\n        Abstraction abstractionA = new ConcreteAbstractionA(implementorA);\n        abstractionA.operation();\n\n        System.out.println(\"------\");\n\n        Abstraction abstractionB = new ConcreteAbstractionB(implementorB);\n        abstractionB.operation();\n    &#125;\n&#125;\n//在上述示例代码中，抽象部分（Abstraction）定义了抽象类或接口，并包含一个指向实现部分的引用（Implementor）。具体抽象部分（ConcreteAbstractionA和ConcreteAbstractionB）继承自抽象部分，并实现了抽象部分的操作方法，将具体的操作委托给实现部分。\n\n//实现部分（Implementor）定义了实际的实现类，它独立于抽象部分。具体实现部分（ConcreteImplementorA和ConcreteImplementorB）实现了实现部分的操作方法。\n\n\n\n组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。\n将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n\n\n\n\n\n\n\n\n应用实例：1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。\n\ncode\n// 组件抽象类\nabstract class Component &#123;\n    protected String name;\n\n    public Component(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public abstract void operation();\n    public abstract void add(Component component);\n    public abstract void remove(Component component);\n    public abstract void getChild(int index);\n&#125;\n\n// 叶子组件类\nclass Leaf extends Component &#123;\n    public Leaf(String name) &#123;\n        super(name);\n    &#125;\n\n    public void operation() &#123;\n        System.out.println(\"Leaf \" + name + \" operation\");\n    &#125;\n\n    public void add(Component component) &#123;\n        // 叶子节点无法添加子节点，抛出异常或忽略操作\n    &#125;\n\n    public void remove(Component component) &#123;\n        // 叶子节点无法删除子节点，抛出异常或忽略操作\n    &#125;\n\n    public void getChild(int index) &#123;\n        // 叶子节点无法获取子节点，抛出异常或忽略操作\n    &#125;\n&#125;\n\n// 容器组件类\nclass Composite extends Component &#123;\n    private List&lt;Component> components;\n\n    public Composite(String name) &#123;\n        super(name);\n        components = new ArrayList&lt;>();\n    &#125;\n\n    public void operation() &#123;\n        System.out.println(\"Composite \" + name + \" operation\");\n        for (Component component : components) &#123;\n            component.operation();\n        &#125;\n    &#125;\n\n    public void add(Component component) &#123;\n        components.add(component);\n    &#125;\n\n    public void remove(Component component) &#123;\n        components.remove(component);\n    &#125;\n\n    public void getChild(int index) &#123;\n        components.get(index);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Component leaf1 = new Leaf(\"Leaf 1\");\n        Component leaf2 = new Leaf(\"Leaf 2\");\n        Component leaf3 = new Leaf(\"Leaf 3\");\n\n        Composite composite1 = new Composite(\"Composite 1\");\n        composite1.add(leaf1);\n        composite1.add(leaf2);\n\n        Composite composite2 = new Composite(\"Composite 2\");\n        composite2.add(leaf3);\n        composite2.add(composite1);\n\n        composite2.operation();\n    &#125;\n&#125;\n\n\n\n享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。\n运用共享技术有效地支持大量细粒度的对象。\n享元模式适用于以下场景：\n\n当需要创建大量相似对象时，可以使用享元模式来减少对象的数量，节省内存空间。\n当对象的内部状态和外部状态可以分离，并且内部状态可以共享时，可以使用享元模式。\n\n\n\n\n\n\n\n\n\n\n应用实例：1、Java中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面；2、数据库的数据池。\n\ncode\n// 抽象享元类\ninterface Flyweight &#123;\n    void operation(String extrinsicState);\n&#125;\n\n// 具体享元类\nclass ConcreteFlyweight implements Flyweight &#123;\n    private String intrinsicState;\n\n    public ConcreteFlyweight(String intrinsicState) &#123;\n        this.intrinsicState = intrinsicState;\n    &#125;\n\n    public void operation(String extrinsicState) &#123;\n        System.out.println(\"Intrinsic State: \" + intrinsicState);\n        System.out.println(\"Extrinsic State: \" + extrinsicState);\n    &#125;\n&#125;\n\n// 享元工厂类\nclass FlyweightFactory &#123;\n    private Map&lt;String, Flyweight> flyweights;\n\n    public FlyweightFactory() &#123;\n        flyweights = new HashMap&lt;>();\n    &#125;\n\n    public Flyweight getFlyweight(String key) &#123;\n        if (flyweights.containsKey(key)) &#123;\n            return flyweights.get(key);\n        &#125; else &#123;\n            Flyweight flyweight = new ConcreteFlyweight(key);\n            flyweights.put(key, flyweight);\n            return flyweight;\n        &#125;\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        FlyweightFactory factory = new FlyweightFactory();\n\n        Flyweight flyweight1 = factory.getFlyweight(\"A\");\n        flyweight1.operation(\"State 1\");\n\n        Flyweight flyweight2 = factory.getFlyweight(\"A\");\n        flyweight2.operation(\"State 2\");\n\n        Flyweight flyweight3 = factory.getFlyweight(\"B\");\n        flyweight3.operation(\"State 3\");\n    &#125;\n&#125;\n\n//在上述示例代码中，抽象享元类（Flyweight）定义了享元对象的共同操作方法operation。具体享元类（ConcreteFlyweight）实现了抽象享元类，并包含了内部状态（intrinsicState）。\n\n//享元工厂类（FlyweightFactory）负责创建和管理享元对象。它通过一个HashMap来缓存已经创建的享元对象，当需要获取享元对象时，先查找缓存中是否已经存在，如果存在则直接返回，否则创建一个新的享元对象并放入缓存中。\n\n\n\n\n\n\n\n\n\n\n\n有的我也没见过😂\n","slug":"设计模式-3结构型","date":"2022-12-24T02:31:09.000Z","categories_index":"java","tags_index":"设计模式","author_index":"Ushioiu"},{"id":"624c128252ebb259922a7e5e7b2f25d4","title":"设计模式-2创建型","content":"设计模式-2——创建型模式——工厂模式工厂模式（Factory Pattern）是Java中最常用的设计模式之一。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n\n\n\n\n\n\n\n\n\n应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。而至于需要哪个牌子的汽车，就到哪个牌子的工厂。\n在Java中，有三种常见的工厂模式实现方式：\n\n简单工厂模式（Simple Factory Pattern）：由一个工厂类负责创建对象，根据传入的参数决定实例化哪个具体的类。客户端只需要和工厂类进行交互，而不需要直接与具体的产品类打交道。这种模式提供了较强的封装性，但不满足开闭原则，当需求变化时需要修改工厂类。\n\n简单工厂模式-java代码\n// 产品接口\ninterface Product &#123;\n    void operation();\n&#125;\n\n// 具体产品A\nclass ConcreteProductA implements Product &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductA operation\");\n    &#125;\n&#125;\n\n// 具体产品B\nclass ConcreteProductB implements Product &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductB operation\");\n    &#125;\n&#125;\n\n// 工厂类\nclass SimpleFactory &#123;\n    public static Product createProduct(String type) &#123;\n        if (type.equals(\"A\")) &#123;\n            return new ConcreteProductA();\n        &#125; else if (type.equals(\"B\")) &#123;\n            return new ConcreteProductB();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Product productA = SimpleFactory.createProduct(\"A\");\n        productA.operation();\n\n        Product productB = SimpleFactory.createProduct(\"B\");\n        productB.operation();\n    &#125;\n&#125;\n\n\n\n\n工厂方法模式（Factory Method Pattern）：定义一个创建对象的接口，让子类决定实例化哪个具体的类。这样将对象的实例化延迟到子类中，客户端可以通过抽象的接口操作具体的产品对象。工厂方法模式符合开闭原则，但需要客户端与具体的工厂类进行交互。\n\n工厂方法模式-java代码\n// 产品接口\ninterface Product &#123;\n    void operation();\n&#125;\n\n// 具体产品A\nclass ConcreteProductA implements Product &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductA operation\");\n    &#125;\n&#125;\n\n// 具体产品B\nclass ConcreteProductB implements Product &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductB operation\");\n    &#125;\n&#125;\n\n// 工厂接口\ninterface Factory &#123;\n    Product createProduct();\n&#125;\n\n// 具体工厂A\nclass ConcreteFactoryA implements Factory &#123;\n    @Override\n    public Product createProduct() &#123;\n        return new ConcreteProductA();\n    &#125;\n&#125;\n\n// 具体工厂B\nclass ConcreteFactoryB implements Factory &#123;\n    @Override\n    public Product createProduct() &#123;\n        return new ConcreteProductB();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Factory factoryA = new ConcreteFactoryA();\n        Product productA = factoryA.createProduct();\n        productA.operation();\n\n        Factory factoryB = new ConcreteFactoryB();\n        Product productB = factoryB.createProduct();\n        productB.operation();\n    &#125;\n&#125;\n\n\n\n抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。客户端通过抽象的接口操作产品，而具体的产品创建细节由具体的工厂子类实现。抽象工厂模式具有较高的扩展性，但增加新的产品族需要修改抽象工厂接口和所有的具体工厂类。\n\n抽象工厂模式-java代码\n// 产品接口A\ninterface ProductA &#123;\n    void operation();\n&#125;\n\n// 具体产品A1\nclass ConcreteProductA1 implements ProductA &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductA1 operation\");\n    &#125;\n&#125;\n\n// 具体产品A2\nclass ConcreteProductA2 implements ProductA &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductA2 operation\");\n    &#125;\n&#125;\n\n// 产品接口B\ninterface ProductB &#123;\n    void operation();\n&#125;\n\n// 具体产品B1\nclass ConcreteProductB1 implements ProductB &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductB1 operation\");\n    &#125;\n&#125;\n\n// 具体产品B2\nclass ConcreteProductB2 implements ProductB &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"ConcreteProductB2 operation\");\n    &#125;\n&#125;\n\n// 抽象工厂接口\ninterface AbstractFactory &#123;\n    ProductA createProductA();\n    ProductB createProductB();\n&#125;\n\n// 具体工厂1\nclass ConcreteFactory1 implements AbstractFactory &#123;\n    @Override\n    public ProductA createProductA() &#123;\n        return new ConcreteProductA1();\n    &#125;\n\n    @Override\n    public ProductB createProductB() &#123;\n        return new ConcreteProductB1();\n    &#125;\n&#125;\n\n// 具体工厂2\nclass ConcreteFactory2 implements AbstractFactory &#123;\n    @Override\n    public ProductA createProductA() &#123;\n        return new ConcreteProductA2();\n    &#125;\n\n    @Override\n    public ProductB createProductB() &#123;\n        return new ConcreteProductB2();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        AbstractFactory factory1 = new ConcreteFactory1();\n        ProductA productA1 = factory1.createProductA();\n        productA1.operation();\n        ProductB productB1 = factory1.createProductB();\n        productB1.operation();\n\n        AbstractFactory factory2 = new ConcreteFactory2();\n        ProductA productA2 = factory2.createProductA();\n        productA2.operation();\n        ProductB productB2 = factory2.createProductB();\n        productB2.operation();\n    &#125;\n&#125;\n\n\n\n\n抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\n提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n\n\n\n\n\n\n\n\n应用实例：对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。\n代码见上面的抽象工厂\n单例模式单例模式（Singleton Pattern）是Java中最简单的设计模式之一。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n\n\n\n\n\n\n\n\n应用实例：一个班级只能有一个班主任。\n以下是在Java中实现单例模式的常见代码示例：\n\n懒汉式，线程不安全：\n\n懒汉，线程不安全\npublic class Singleton &#123;\n    private static Singleton instance;\n\n    private Singleton() &#123;\n        // 私有构造函数\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        if (instance == null) &#123;\n            instance = new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n\n\n懒汉式，线程安全（使用synchronized关键字）：\n\n\n懒汉，线程安全\npublic class Singleton &#123;\n    private static Singleton instance;\n\n    private Singleton() &#123;\n        // 私有构造函数\n    &#125;\n\n    public static synchronized Singleton getInstance() &#123;\n        if (instance == null) &#123;\n            instance = new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n\n\n饿汉式，线程安全：\n\n饿汉，线程安全\npublic class Singleton &#123;\n    private static final Singleton instance = new Singleton();\n\n    private Singleton() &#123;\n        // 私有构造函数\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n\n\n\n双重检验锁，线程安全：\n\n双重检验锁\npublic class Singleton &#123;\n    private volatile static Singleton instance;\n\n    private Singleton() &#123;\n        // 私有构造函数\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        if (instance == null) &#123;\n            synchronized (Singleton.class) &#123;\n                if (instance == null) &#123;\n                    instance = new Singleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n\n\n静态内部类，线程安全：\n\n静态内部类\npublic class Singleton &#123;\n    private Singleton() &#123;\n        // 私有构造函数\n    &#125;\n\n    private static class SingletonHolder &#123;\n        private static final Singleton instance = new Singleton();\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n&#125;\n\n\n\n\n建造者模式（构建者模式）建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。\n一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。\n将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n\n\n\n\n\n\n\n\n应用实例：1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”；2、Java 中的 StringBuilder。\n以下是建造者模式的示例代码：\n\n构建者模式\n// 产品类\nclass Product &#123;\n    private String partA;\n    private String partB;\n    private String partC;\n\n    public void setPartA(String partA) &#123;\n        this.partA = partA;\n    &#125;\n\n    public void setPartB(String partB) &#123;\n        this.partB = partB;\n    &#125;\n\n    public void setPartC(String partC) &#123;\n        this.partC = partC;\n    &#125;\n\n    public void show() &#123;\n        System.out.println(\"Product parts: \" + partA + \", \" + partB + \", \" + partC);\n    &#125;\n&#125;\n\n// 抽象建造者类\ninterface Builder &#123;\n    void buildPartA();\n    void buildPartB();\n    void buildPartC();\n    Product getResult();\n&#125;\n\n// 具体建造者类\nclass ConcreteBuilder implements Builder &#123;\n    private Product product;\n\n    public ConcreteBuilder() &#123;\n        product = new Product();\n    &#125;\n\n    @Override\n    public void buildPartA() &#123;\n        product.setPartA(\"Part A\");\n    &#125;\n\n    @Override\n    public void buildPartB() &#123;\n        product.setPartB(\"Part B\");\n    &#125;\n\n    @Override\n    public void buildPartC() &#123;\n        product.setPartC(\"Part C\");\n    &#125;\n\n    @Override\n    public Product getResult() &#123;\n        return product;\n    &#125;\n&#125;\n\n// 指导者类\nclass Director &#123;\n    public void construct(Builder builder) &#123;\n        builder.buildPartA();\n        builder.buildPartB();\n        builder.buildPartC();\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Builder builder = new ConcreteBuilder();\n        Director director = new Director();\n\n        director.construct(builder);\n        Product product = builder.getResult();\n        product.show();\n    &#125;\n&#125;\n//在上述示例代码中，有一个产品类（Product），包含了三个部分（partA，partB，partC），并提供了设置部分的方法和展示产品的方法。\n\n//抽象建造者类（Builder）定义了构建产品的步骤，具体的建造者类（ConcreteBuilder）实现了这些步骤，并提供了一个获取产品的方法。\n\n//指导者类（Director）负责指导构建过程，并通过调用建造者的方法来构建产品。\n\n\n\n原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。\n这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。\n用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\n\n\n\n\n\n\n\n\n应用实例：1、细胞分裂；2、Java中的 Object clone() 方法。\n以下是原型模式的示例代码：\n\n原型模式\n// 原型接口\ninterface Prototype &#123;\n    Prototype clone();\n&#125;\n\n// 具体原型类\nclass ConcretePrototype implements Prototype &#123;\n    private String name;\n\n    public ConcretePrototype(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    @Override\n    public Prototype clone() &#123;\n        return new ConcretePrototype(name);\n    &#125;\n&#125;\n\n// 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        ConcretePrototype prototype = new ConcretePrototype(\"Prototype\");\n\n        // 使用原型对象创建新对象\n        ConcretePrototype clone = (ConcretePrototype) prototype.clone();\n        System.out.println(\"Original Object: \" + prototype.getName());\n        System.out.println(\"Cloned Object: \" + clone.getName());\n    &#125;\n&#125;\n\n\n\n","slug":"设计模式-2创建型","date":"2022-12-23T03:42:12.000Z","categories_index":"java","tags_index":"设计模式","author_index":"Ushioiu"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"一、设计模式的六大原则（SOLID）总原则——开闭原则（Open Closed Principle）\n\n\n\n\n\n\n\n\n\n一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。\n在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。\n想要达到这样的效果，我们需要使用接口和抽象类等。\n1、单一职责原则（Single Responsibility Principle）\n\n\n\n\n\n\n\n\n\n一个类应该只有一个发生变化的原因。\n不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。\n2、里氏替换原则（Liskov Substitution Principle）\n\n\n\n\n\n\n\n\n\n所有引用基类的地方必须能透明地使用其子类的对象。\n任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n3、依赖倒置原则（Dependence Inversion Principle）\n\n\n\n\n\n\n\n\n\n1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。2、抽象不应该依赖于细节，细节应该依赖于抽象。\n面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n4、接口隔离原则（Interface Segregation Principle）\n\n\n\n\n\n\n\n\n\n1、客户端不应该依赖它不需要的接口。2、类间的依赖关系应该建立在最小的接口上。\n每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\n5、迪米特法则（最少知道原则）(Law of Demeter)\n\n\n\n\n\n\n\n\n\n只与你的直接朋友交谈，不跟“陌生人”说话。\n一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。\n最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。\n6、合成复用原则（Composite Reuse Principle）\n\n\n\n\n\n\n\n\n\n尽量使用对象组合&#x2F;聚合，而不是继承关系达到软件复用的目的。\n合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。\n记忆口诀：SOLID CD（稳固的CD）。\n\n二、设计模式的三大类创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。\n（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式\n记忆口诀：创工原单建抽（创公园，但见愁）\n\n结构型模式（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。\n（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式\n记忆口诀：结享外组适代装桥（姐想外租，世代装桥）\n\n行为型模式（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。\n（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式\n记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）\n\n\n\n\n\n\n\n\n\n相关：https://zhuanlan.zhihu.com/p/128145128\n","slug":"设计模式","date":"2022-12-23T03:22:13.000Z","categories_index":"java","tags_index":"设计模式","author_index":"Ushioiu"},{"id":"cf2530e605eef344277b43fda2e83990","title":"索引失效及解决方案","content":"索引失效及解决方案失效原因&#x2F;场景\n索引列不独立\n使用了左模糊\n使用 or 查询部分字段没有使用索引\n字符串条件没有使用 ‘’\n不符合最左前缀原则的查询\n索引字段没有添加 not null 约束\n隐式转换导致索引失效\n\n索引列不独立是指 被索引的这列不能是表达式的一部分，不能是函数的参数，比如下面的这种情况select id,name,age,salary from table_name where salary + 1000 &#x3D; 6000;\n\nsalary 列被用户表达式的计算了，这种情况下索引就会失效，解决方式就是提前计算好条件值，不要让索引列参与表达式计算，修改后 sql 如下\nselect id,name,age,salary from table_name where salary &#x3D; 5000;\n\n索引字段作为函数的参数select id,name,age,salary from table_name where substring(name,1,3)&#x3D; &#39;luc&#39;;\n\n解决方式是什么呢，可以提前计算好条件，不要使用索引，或者可以使用其他的 sql 替换上面的，比如，上面的sql 可以使用 like 来代替\nselect id,name,age,salary from table_name where name like &#39;luc%&#39;;\n\n使用了左模糊select id,name,age,salary from table_name where name like &#39;%lucs%&#39;;\n\n平时尽可能避免用到左模糊，可以这样写\nselect id,name,age,salary from table_name where name like &#39;lucs%&#39;;\n\n如果实在避免不了左模糊查询的话，考虑一下搜索引擎 比如 ES\nor 查询部分字段没有使用索引select id,name,age,salary from table_name where name &#x3D;&#39;lucs&#39; and age &gt;25\n\n这种情况，可以为 name 和 age 都建立索引，否则会走全表扫描。\n字符串条件没有使用 ‘’select id,name,age,salary from table_name where phone&#x3D;13088772233 \n\n上面的这条 sql phone 字段类型是 字符串类型的，但是没有使用 ‘13088772233 ‘, SQL 就全表扫描了，所以字符串索引要使用 ‘’\nselect id,name,age,salary from table_name where phone&#x3D;&#39;13088772233 &#39;\n\n不符合最左前缀原则的查询例如有这样一个组合索引 index(a,b,c)\nselect * from table_name where b&#x3D;&#39;1&#39;and c&#x3D;&#39;2&#39;\nselect * from table_name where c&#x3D;&#39;2&#39;\n-- 上面这两条 SQL 都是无法走索引执行的\n\n最左原则，就是要最左边的优先存在，我不在的话，你们自己就玩不动了，除非你自己单独创立一个索引，下面这几条 SQL 就可以走索引执行\nselect * from table_name where a &#x3D; &#39;asaa&#39; and b&#x3D;&#39;1&#39;and c&#x3D;&#39;2&#39;\nselect * from table_name where a &#x3D; &#39;asda&#39; and b&#x3D;&#39;1231&#39; \n-- 上面这两条是走索引的，但是下面这条你觉得索引应该怎么走，是全部走，还是部分走索引？\nselect * from table_name where a &#x3D; &#39;asda&#39; and c&#x3D;&#39;dsfsdafsfsd&#39; \n\n索引字段没有添加 not null 约束select * from table_name where a is null;\n-- 这条sql就无法走索引执行了，is null 条件 不能使用索引，只能全表扫描了\n-- mysql 官方建议是把字段设置为 not null \n\n隐式转换关联表的两个字段类型不一致会发生隐式转换\nselect * from table_name t1 left join table_name2 t2 on t1.id&#x3D;t2.tid;\n-- 上面这条语句里，如果 t1 表的id 类型和 t2 表的tid 类型不一致的时候，就无法\n-- 按索引执行了。\n-- 解决方式就是统一设置字段类型。\n\n\n\n\n\n\n\n\n\n\n转载：https://zhuanlan.zhihu.com/p/166247445\n","slug":"索引失效及解决方案","date":"2022-11-09T02:18:21.000Z","categories_index":"数据库","tags_index":"索引失效","author_index":"Ushioiu"},{"id":"4d8037d4e1b16b3676d4b80209195ebc","title":"系统架构演变","content":"1.单体架构比如我们一开始写的ssm框架就是，从数据库访问层，业务逻辑层，控制层，从前端到后端都是一起开发的单体应用。\n\n优点：部署在一个节点上，维护方便，开发方便。\n缺点：一处错可能导致应用出错，代码耦合性高，不方便扩展，不利于开发大项目\n2.垂直应用架构随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量。\n\n优点：可以分担流量，解决并发问题，不同模块方便开发，扩展\n缺点：代码重复度高，模块（应用）之间独立无法相互调用\n3.分布式架构在垂直应用的架构上，把重复的部分提取出来\n\n优点：提高代码复用（把公共功能提取，作为服务层）\n缺点：系统之间耦合性变高，调用复杂，难维护\n4.SOA架构在分布式下，设想一下，服务越来越多，他们之间的调用关系是不是更加复杂？\n于是，资源调度和治理中心(SOA Service OrientedArchitecture，面向服务的架构)很关键\n\n例如：当a功能需要b是，请求ESB，ESB寻找然后找到b，帮a的请求转发到b。\n优点：注册中心管理服务调用关系\n缺点：测试，部署，运维困难，依赖关系复杂，出错影响大\n5.微服务在SOA基础上，让SOA架构粒度更精细，目的就是为了让服务之间互不影响\n\n比SOA粒度更精细，每个服务单独数据库\n优点：\n\n服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展\n微服务之间采用Restful等轻量级http协议相互调用\n\n缺点：\n\n开发成本高\n\n","slug":"系统架构发展","date":"2022-10-10T12:18:21.000Z","categories_index":"java","tags_index":"系统架构","author_index":"Ushioiu"},{"id":"5c0f27a0ed8d73f08892501931e4fc3a","title":"HashMap底层原理","content":"HashMap的原理与实现JDK1.8之前：数组+链表\nJDK1.8：数组+链表&#x2F;红黑树\n对比：\njdk8当链表大于等于8会变成红黑树\njdk7采用的是插入头节点，jdk8采用的是插入尾节点（因为红黑树）\njdk8，hash算法的简化，并且不会出现死循环\n\n1.扩容机制&#x2F;**\n   * The load factor used when none specified in constructor.\n   *&#x2F;\n  static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n  &#x2F;**\n   *默认的负载因子是0.75f,也就是75% 负载因子的作用就是计算扩容阈值用，比如说使用\n   *无参构造方法创建的HashMap 对象，他初始长度默认是16  阈值 &#x3D; 当前长度 * 0.75  就\n   *能算出阈值，当当前长度大于等于阈值的时候HashMap就会进行自动扩容\n   *--扩容因子越大 越容易hash冲突，越小消耗空间越大 ，0.75比较合适\n   *--保证扩容后容量是2的幂，0.75也比较合适（位运算）\n   *&#x2F;\n\n2.储存原理\n把key通过hash算法获取hash值\n调用indexFor方法，通过获取到的hash值以及数组的长度算出数组的下标\n把key，value存到数组对应下标中（封装成node对象，如果有值了，就会尾插成链表）\n特殊情况也就是链表变成红黑树了：\n没有对应的key然后插入，红黑树自己平衡\n有对应的key，实现替换，红黑树自动平衡\n简单提一句链表怎么转变红黑树：当链表长度大于等于8时，下一次的插入元素使链表依然大于等于8，那么就会重写，重现分配数据变成红黑树，当删除红黑树元素时，如果红黑树节点数（总结点）小于等于6，自动转成链表（再重写）。（至于hashmap扩容怎么数据迁移就很复杂了）\n\n\n\n","slug":"HashMap底层原理","date":"2022-10-03T02:42:33.000Z","categories_index":"java","tags_index":"HashMap","author_index":"Ushioiu"}]