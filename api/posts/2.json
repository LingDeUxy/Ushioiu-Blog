{"total":17,"pageSize":12,"pageCount":2,"data":[{"title":"设计模式-2创建型","uid":"624c128252ebb259922a7e5e7b2f25d4","slug":"设计模式-2创建型","date":"2022-12-23T03:42:12.000Z","updated":"2023-07-10T11:29:19.508Z","comments":true,"path":"api/articles/设计模式-2创建型.json","cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"设计模式-2——创建型模式——工厂模式工厂模式（Factory Pattern）是Java中最常用的设计模式之一。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"设计模式","uid":"deffdaaa2a24a19ee257667b3b36743c","slug":"设计模式","date":"2022-12-23T03:22:13.000Z","updated":"2023-07-10T08:08:02.750Z","comments":true,"path":"api/articles/设计模式.json","cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"一、设计模式的六大原则（SOLID）总原则——开闭原则（Open Closed Principle） 一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"索引失效及解决方案","uid":"cf2530e605eef344277b43fda2e83990","slug":"索引失效及解决方案","date":"2022-11-09T02:18:21.000Z","updated":"2023-07-06T07:30:13.191Z","comments":true,"path":"api/articles/索引失效及解决方案.json","cover":"https://tse1-mm.cn.bing.net/th/id/OIP-C.peU5b4iXsv9YM_os6ZD7CgAAAA?w=154&h=180&c=7&r=0&o=5&pid=1.7","text":"索引失效及解决方案失效原因&#x2F;场景 索引列不独立 使用了左模糊 使用 or 查询部分字段没有使用索引 字符串条件没有使用 ‘’ 不符合最左前缀原则的查询 索引字段没有添加 not null 约束 隐式转换导致索引失效 索引列不独立是指 被索引的这列不能是表达式的一部分，不...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"索引失效","slug":"索引失效","count":1,"path":"api/tags/索引失效.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"系统架构演变","uid":"4d8037d4e1b16b3676d4b80209195ebc","slug":"系统架构发展","date":"2022-10-10T12:18:21.000Z","updated":"2023-07-06T07:03:23.739Z","comments":true,"path":"api/articles/系统架构发展.json","cover":"/img/post/image-20230705191839467.png","text":"1.单体架构比如我们一开始写的ssm框架就是，从数据库访问层，业务逻辑层，控制层，从前端到后端都是一起开发的单体应用。 优点：部署在一个节点上，维护方便，开发方便。 缺点：一处错可能导致应用出错，代码耦合性高，不方便扩展，不利于开发大项目 2.垂直应用架构随着访问量的逐渐增大，单...","link":"","photos":[],"count_time":{"symbolsCount":650,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"系统架构","slug":"系统架构","count":1,"path":"api/tags/系统架构.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}},{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"HashMap底层原理","date":"2022-10-03T02:42:33.000Z","updated":"2023-07-06T07:04:43.629Z","comments":true,"path":"api/articles/HashMap底层原理.json","cover":"/img/post/like.jpg","text":"HashMap的原理与实现JDK1.8之前：数组+链表 JDK1.8：数组+链表&#x2F;红黑树 对比： jdk8当链表大于等于8会变成红黑树 jdk7采用的是插入头节点，jdk8采用的是插入尾节点（因为红黑树） jdk8，hash算法的简化，并且不会出现死循环 1.扩容机制&...","link":"","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":7,"path":"api/categories/java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"}],"author":{"name":"Ushioiu","slug":"blog-author","avatar":"/img/account/ikun.jpeg","link":"/","description":"重新整理搭建博客中...","socials":{"github":"https://github.com/LingDeUxy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"https://blog.csdn.net/qq_62219631","juejin":"https://juejin.cn/user/1621110612306008","customs":{}}}}]}